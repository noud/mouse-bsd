<!-- $NetBSD: driver6.html,v 1.1 1998/12/30 20:20:34 mcr Exp $ -->
<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML Strict//EN">
<html><head><title>
IRIG Audio Decoder
</title></head><body><h3>
IRIG Audio Decoder
</h3><hr>

<p><h4>Synopsis</h4>

<p>Address: 127.127.6.<var>u</var>
<br>Reference ID: IRIG
<br>Driver ID: IRIG-AUDIO
<br>Audio Device: <code>/dev/irig<var>u</var></code>
<br>Requires: modified SunOS 4.1.3 BSD audio driver and
<code>/usr/include/sys/bsd_audioirig.h</code> header file

<p><h4>Description</h4>

<p>This driver supports the Inter-Range Instrumentation Group standard
time-distribution signal IRIG-B using the audio codec native to the Sun
SPARCstation. This signal is generated by several radio clocks,
including those made by Austron, TrueTime, Odetics and Spectracom, among
others, although it is generally an add-on option. The signal is
connected via an attenuator box and cable to the audio codec input on a
Sun SPARCstation and requires a specially modified kernel audio driver
described in the <a href="irig.html">IRIG Support Using Sun SPARC
Audio</a> page.

<p>The driver requires a modified SunOS 4.1.3 BSD audio driver available
from the archive host ftp.udel.edu as the compressed tar archive
<code>pub/ntp/bsd_audio.tar.Z</code>. For ordinary audio applications,
the audio driver is transparent; for use with the NTP driver, the audio
driver decodes the IRIG audio signals and provides a timestamp, raw
binary timecode, status byte and decoded ASCII timecode. The data are
represented in the structure in the sys/bsd_audioirig.h header file:

<pre>
     struct irig_time {
          struct timeval stamp;    /* timestamp */
          u_char    bits[13];      /* 100 IRIG data bits */
          u_char    status;        /* status byte */
          char      time[14];      /* time string (null terminated) */
</pre>

<p>where stamp represents a timestamp at the zero crossing of the index
marker at the second's epoch, bits is a 13-octet, zero-padded binary-
coded string representing code elements 1 through 100 in the IRIG-B code
format, and status is a status byte, The decoded timestamp is a 13-
octet, null-terminated ASCII string <code>ddd hh:mm:ss*</code>, where
ddd is the day of year, hh:mm:ss the time of day and <code>*</code> is a
status indicator, with ' ' indicating valid time and '?' indicating
something wrong.

<p>The timestamp is in Unix timeval format, consisting of two 32-bit
words, the first of which is the seconds since 1970 and the second is
the fraction of the second in microseconds. The status byte is zero if
(a) the input signal is within amplitude tolerances, (b) the raw binary
timecode contains only valid code elements, (c) 11 position identifiers
have been found at the expected element positions, (d) the clock status
byte contained in the timecode is valid, and (e) a time determination
has been made since the last read() system call.

<p>The 100 elements of the IRIG-B timecode are numbered from 0 through
99. Position identifiers occur at elements 0, 9, 19 and every ten
thereafter to 99. The control function (CF) elements begin at element 50
(CF 1) and extend to element 78 (CF 27). The straight-binary-seconds
(SBS) field, which encodes the seconds of the UTC day, begins at element
80 (CF 28) and extends to element 97 (CF 44). The encoding of elements
50 (CF 1) through 78 (CF 27) is device dependent. This driver presently
does not use the CF elements.

<p>Where feasible, the interface should be operated with signature
control, so that, if the IRIG signal is lost or malformed, the interface
produces an unmodulated signal, rather than possibly random digits. The
driver will declare itself unsynchronized in this case.

<pre>
     Element   CF        Function
     -------------------------------------
     55        6         time sync status
     60-63     10-13     bcd year units
     65-68     15-18     bcd year tens
</pre>

<p>Timing jitter using the decoder and a Sun IPC is in the order of a
few microseconds, although the overall timing accuracy is limited by the
wander of the CPU oscillator used for timing purposes to a few hundred
microseconds. These figures are comparable with what can be achieved
using the PPS discipline as describe elsewhere in this note.

<p><h4>Monitor Data</h4>

<p>The driver writes each timecode as received to the
<code>clockstats</code> file.

<p><h4>Fudge Factors</h4>

<dl>

<dt><code>time1 <i>time</i></code>
<dd>Specifies the time offset calibration factor, in seconds and
fraction, with default 0.0.

<p><dt><code>time2 <i>time</i></code>
<dd>Not used by this driver.

<p><dt><code>stratum <i>number</i></code>
<dd>Specifies the driver stratum, in decimal from 0 to 15, with default
0.

<p><dt><code>refid <i>string</i></code>
<dd>Specifies the driver reference identifier, an ASCII string from one
to four characters, with default <code>IRIG</code>.

<p><dt><code>flag1 0 | 1</code>
<dd>Not used by this driver.

<p><dt><code>flag2 0 | 1</code>
<dd>Not used by this driver.

<p><dt><code>flag3 0 | 1</code>
<dd>Not used by this driver.

<p><dt><code>flag4 0 | 1</code>
<dd>Enable <code>clockstats</code> recording if set.

</dl>

<p>Additional Information

<p><a href="refclock.html"> Reference Clock Drivers</a>

<hr><address>David L. Mills (mills@udel.edu)</address></body></html>
