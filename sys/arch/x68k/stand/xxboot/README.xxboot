#	$NetBSD: README.xxboot,v 1.1 1998/09/01 20:02:33 itohy Exp $

		xxboot version 0.3

xxboot は:

NetBSD/x68k を起動するためのブートプログラムです。
次のデバイスからのブートに対応しています。

  o SCSI ディスクの先頭 7 パーティション
  o フロッピーディスクの次の物理フォーマットのもの
      1232KB (1024byte/sector, 8sector/track): X68k 標準フォーマット
      1200KB (512byte/sector, 15sector/track): 俗に 2HC とかいうやつ

注意:	現在のところ、1232KB フォーマットのディスク上には
	正常にファイルシステムが構築できませんので、root ファイルシステム
	などをこのフォーマットのディスクに置くことはできません。
	ただし、ファイルシステムを一旦 vnode disk driver (vnd) 上に作成して
	からフロッピーに書き込むことにより、memory disk (md) を root として
	起動するブートディスクを作成することは可能です。


sdboot, fdboot との違い:

xxboot は、NetBSD 1.2 に含まれている sdboot (chapuni氏作) や fdboot と
同じような機能を持っています。主な機能的な違いは次のようなものです。

  o SCSI ディスクとフロッピーとで同じバイナリを使う。

  o gzip で圧縮されたカーネルを読み込むことができる。
    それにともない、デフォルトで読み込むカーネルのファイル名
    として、netbsd のほかに netbsd.gz が加えられた。

要するに、sdboot, fdboot, gunzip をつぎはぎしたもですね。


install:

1. make します
	% make

2. /usr/mdec に置きます。
	# make install


ディスクへの書き込み:

a. フロッピー
    予め disklabel を書いたディスクに対して installboot で書き込みます。
	# /usr/mdec/installboot /usr/mdec/fdboot /dev/rfd0c
	                                                 ^^
    ^^ の部分は書き込み先によって変更します。

b. SCSI ディスク
	# /usr/mdec/installboot /usr/mdec/sdboot /dev/rsd0a
	                                                 ^^
    ^^ の部分は書き込み先によって変更します。


使いかたなど:

sdboot と全く同じです。README.sdboot などを参照してください。
(ああなんて手抜き)

カーネルを gzip で圧縮して使用する場合は、
あらかじめ、圧縮しない状態で、一度マルチユーザブートするか、
kvm_mkdb を実行して /var/db/kvm.db を作成しておくと、
ps などのカーネルを参照するコマンドも正常に動作するようです。


エラー:

xxboot は、エラーを検出すると、

	xxboot: unsupported boot device
	[Hit key to reboot]

のような表示をしてキー入力待ちになります。
ここで何かキーを押すとソフトウェアリセットがかかって再起動します。
エラーには次のようなものがあります:

"4MB RAM required"
	主記憶が 4MB より少ないので xxboot をロードできません。
	4MB 以上実装してあるのにこれが表示される時は、switch.x で
	メモリスイッチを確認してください。

"MPU 68000?"
	68000, 68008, 68010 でブートしようとしました。

"unsupported boot device"
	現在のところ、このデバイスからのブートはできません。
	きっと SASI HD か SRAM から起動しようとしたのでしょう。

"READ ID failed"
	フロッピーのフォーマットを判定するための READ ID が失敗しました。

"READCAP failed"
	SCSI HD のブロック長を調べるための READCAP が失敗しました。

"read error"
	SCSI HD またはフロッピーの読み込みに失敗しました。

"read half of block"
	ディスクのブロック(セクタ)よりファイルシステムのブロックが短いと
	このエラーになることがあります。

"Can't boot from this partition"
	先頭 7 個以外のパーティションから起動しようとしました。
	あるいは、起動パーティションの特定に失敗しました。

"bogus super block: ルートファイルシステムが壊れています！"
	正常なスーパーブロックが読めませんでした。

"improper file format: 実行不可能です。"
	カーネルとして読み込んだファイルの形式が異常です。

"invalid compressed data"
"out of memory"
"unknown compression method"
"unsupported compression flag"
	gzip 圧縮されたデータが異常です。


プログラムについて:

ブートプログラムの大部分は chapuni さんが書いたものです。
gzip の展開部分 (gunzip/inflate.c) は、gzip-1.2.4 の
Not copyrighted なコードから拝借しました。
Copyright のある部分は使用せずに私が書き直しましたので、
GPL に従う必要はありません。
私の作成/変更した部分について、(怪し気なスクリプトも含め)
著作権を主張するつもりはありません。

タイトルとして使っている BSD Daemon の著作権は、
Marshall Kirk McKusick 氏(mckusick@mckusick.com)が保持しています。
NetBSD/x68k の boot プログラムに使用して、Berkeley ライセンスで
配布するための許可を頂きました。
容量が残っていれば、バイナリにも "Copyright 1988 McKusick" のような
著作権表示を残してほしい(ただし必須ではない)とのことです。
他に転用する場合は、McKusick 氏に許可を求めてください。

	BSD Daemon Copyright 1988 by Marshall Kirk McKusick.
	All Rights Reserved.

	Permission to use the daemon may be obtained from:
	    Marshall Kirk McKusick
	    1614 Oxford St
	    Berkeley, CA 94709-1608
	    USA
	or via email at mckusick@mckusick.com


変更履歴:
    ver 0.3
	o 1GB 以上の SCSI ディスクからもブートできるようにした。

	o SCSI ディスクの先頭以外のパーティションからもブートできるようにした。

	o エラーチェックを大幅に強化した。
	  また、エラー時にキー入力を待って reboot するようにした。

	o 内蔵、純正 SCSI ボード(またはその互換ボード)、満開 Mach-2 の
	  どれからブートしたかを調べてカーネルに渡すようにした。

	o loadbsd.x と共通のカーネル転送コードを使うようにした。

	o chapuni 氏の野望を引き継ぎ、無意味にグラフィカルにした。

	o さらに、タイトルの絵を差し替えられるツールをこっそり
	  img ディレクトリに置いた。

    ver 0.2
	o タイマ、外部 power on の場合に、正常に動かない不具合を修正した。

	o ソースを一部整理し、また、コードサイズを減らした。

    ver 0.1
	o make depend がうまく動くように xxboot.s → xxboot.S に
	  ファイル名を変更した。

	o GPL なコードを排除した。
	  副作用として、100byte ほどコードが減った。


以下はソースを読む人向けです。

ソースについて:
    ブートプログラム本体は、text+data を 8KB に、bss を 56KB に
    収める必要があります。
    8KB におさめるために、あちらこちらで変なことをしています。
    ちなみに、もうほとんど容量が残っていません。
    gunzip/inflate.c で malloc() を使っていたのですが、
    malloc()/free() のパタンの性質を使って、にせものの
    malloc をでっち上げてあります。malloc() 用のバッファは
    bss ではなくスタックから取っています(bss も残り少ないから)。

	bootufs.c	ブートプログラム本体
	xxboot.S	アセンブリで書いた部分
	chkfmt.s	フロッピーのフォーマットを調べる部分
	iocscall.h	アセンブラ用ヘッダ
	xxboot.h	C 用ヘッダ
	gunzip/*	gzip の展開ルーチン  asm() に注意


メモリマップ:
	000000 |-----------------------------|
	       | 最終的にカーネルは 0 番地に |
	       |         転送される          |
	       |             ↓              |
	002000 |-----------------------------|
	       |xxboot が最初に読まれる(FD)  |
	002400 |-----------------------------|
	       |xxboot が最初に読まれる(SCSI)|
	002800 |-----------------------------|
	       |                             |
	       |                             |
	100000 |-----------------------------|
	       |  カーネル読み込みバッファ   |
	       |             ↓              |
	       |                             |
	       :                             :
	       |                             |
	       |             ↑              |
	       |      gzip の展開に使う      |
	3E8000 |-----------------------------|
	       |             ↑              |
	       |      xxboot のスタック      |
	3F0000 |-----------------------------|
	       | xxboot の text + data (8KB) |
	3F2000 |-----------------------------|
	       |    xxboot の bss (56KB)     |
	3FFFFF |-----------------------------| 4MB マシンの主記憶の上限


ブート動作:
    1.	まず、IOCS や SCSI の IPL により、xxboot の先頭 1KB が、
	0x002000 (フロッピー), 0x002400 (SCSI) に読み込まれ、
	先頭アドレスが実行されます。

    2.	xxboot は、ブートデバイスを調べ、自分自身の全体 (8KB) を
	0x3F0000- にロードし、実行します。

    3.	SHIFT キーが押されていれば 5. へ。

    4.	ルートディレクトリから "netbsd" という名前のファイルを探し、
	0x100000- に読み込みます。"netbsd" が見つからなければ "netbsd.gz"
	も探します。読み込むことができれば 6. へ。

    5.	ルートディレクトリから、"netbsd" あるいは "vmunix" で始まる
	ファイルのリストを作成し、ユーザに選択させます。
	ユーザが選んだファイルを 0x100000- に読み込みます。

    6.	0x100000- に読み込んだファイルが gzip で圧縮されていれば、
	そのファイルを一旦 ??????-0x3E7FFF に転送し、0x100000 が
	先頭になるように展開しなおします。

    7.	0x100000- に読み込んだファイルが NetBSD/m68k の NMAGIC の
    	実行ファイルでなければエラーとします。

    8.	割り込みを禁止します。
	IOCS が低位アドレスをワークとして使っているためです。

    9.	読み込んだファイルの text, data, bss セグメントを
	0x000000- に転送/作成します。

    10.	読み込んだファイルにシンボルテーブルがあれば、
	シンボルテーブル、ストリングテーブルを転送します。

    11.	レジスタ、引数を設定し、カーネルを実行します。


SCSI ディスクの起動パーティション決定アルゴリズム:
    xxboot の起動時の d2 の値が非零であれば、それをキロバイト単位の
    パーティション先頭位置として使う。
    d2 の値が 0 であれば、起動時の a0 がパーティションテーブルを
    指しているとして、(a2 + 8):l & 0x00FFFFFF をキロバイト単位の
    パーティションの先頭位置とする。

    以上の方法で、純正 IPL, SxSI の IPL, BOOT MENU (Ver. 2.22)では
    パーティションの先頭が見つけられるようです。

    Makefile に書かれているコンパイルオプションの -DSCSI_ADHOC_BOOTPART
    を外すと、従来通り先頭パーティション固定になります。


デバッグしたところ:
    シンボルテーブルが無いカーネルでもストリングテーブル
    (シンボル名のテーブル) を転送しようとしていたところを直した。
    (電源投入直後だけフロッピーブートで 暴はる(京ことば) という
     症状に悩まされていた。)


TODO:
  o 1440KB フォーマットのフロッピーからもブートしたいんですが、
    そうすると IOCS が使えないので、自前で読まなければならない
    ことになります。…で、8KB におさまりそうにないですねえ。

  o SASI とか、SASI ポート付きマシンを持っている人におまかせ
    しましょう :-)。あ、NetBSD のデバイスドライバもね。

			---written by Yasha (ITOH Yasufumi)
